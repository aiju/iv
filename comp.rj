struct Process;

struct Signal {
	string name;
	int width;
	string val;
	Process watch[];
};

void
Signal(string name, int width)
{
	this.name = name;
	this.width = width;
	this.val = "x";
	this.watch = [];
}

struct Event {
	void run();
	int time;
};

void
Event(void run(void), int time)
{
	this.run = run;
	this.time = time;
}

struct Process {
	enum {
		PACTIVE,
		PSLEEP,
		PDEAD
	} state;
	System sys;
	string hier;
	void code[]();
	string stack[];
	int pc;
};

void
Process(System sys, string hier)
{
	this.sys = sys;
	this.hier = hier;
	this.code = [];
	this.stack = [];
	this.pc = 0;
	this.state = PACTIVE;
}

struct System {
	Signal sig[string];
	Event active[];
	Event nonblock[];
	Event inactive[];
	Event future[];
	int curtime;
};

void
System(void)
{
	this.sig = {};
	this.active = [];
	this.nonblock = [];
	this.inactive = [];
	this.future = [];
	this.curtime = 0;
}

void
System.addsignal(string hier, Symbol s)
{
	Signal t;
	
	if(s.type.sz.t != ASTCINT)
		throw "size is not a constant";
	t = new Signal(hier + "." + s.name, s.type.sz.numi);
	this.sig[t.name] = t;
}

Signal
System.getsignal(string hier, Symbol s)
{
	return this.sig[hier + "." + s.name];
}

void
System.assign(Signal s, string val)
{
	int i;

	if(s.val != val && s.watch.length != 0){
		for(i = 0; i < s.watch.length; i++)
			this.active.push(new Event(
				(void(Process p)() return void() return p.run())(s.watch[i]), 0));
		s.watch.length = 0;
	}
	s.val = val;
	console.log((string)this.curtime + ": " + s.name + " = " + val);
}

void
System.schedule(void fun(void), int time)
{
	int i;

	if(time <= this.curtime){
		this.inactive.push(new Event(fun, time));
		return;
	}
	for(i = 0; i < this.future.length; i++)
		if(this.future[i].time > i)
			break;
	this.future.splice(i, 0, new Event(fun, time));
}

void
Process.exprcompile(Node n)
{
	Process thisp;
	string v;
	Signal s;
	
	thisp = this;
	switch(n.t){
	case ASTSYM:
		s = this.sys.getsignal(this.hier, n.sym);
		this.code.push(void() return thisp.push(s.val));
		break;
	case ASTCINT:
		v = decconv(0, (string)n.numi).s;
		this.code.push(void() return thisp.push(v));
		break;
	default:
		throw "Process.statcompile: unimplemented " + (string)n.t;
	}
}

void
Process.statcompile(Node n)
{
	int i, delay;
	Process thisp, extrap;
	Signal s;

	thisp = this;
	switch(n.t){
	case ASTBLOCK:
		for(i = 0; i < n.l.length; i++)
			this.statcompile(n.l[i]);
		break;
	case ASTDELAY:
                if(n.n1.t != ASTCINT)
                        error(n.lineno, "delay not a constant");
                delay = n.n1.numi;
		this.code.push(void(){
			thisp.sys.schedule(void() return thisp.run(), thisp.sys.curtime + delay);
			thisp.state = PSLEEP;
		});
		break;
	case ASTAT:
		if(n.l.length != 1 || n.l[0].t != ASTSYM)
			error(n.lineno, "unsupported ASTAT");
		s = this.sys.getsignal(this.hier, n.l[0].sym);
		this.code.push(void(){
			s.watch.push(thisp);
			thisp.state = PSLEEP;
		});
		break;
	case ASTASS:
		if(n.n1.t != ASTSYM)
			error(n.lineno, "invalid lval");
		s = this.sys.getsignal(this.hier, n.n1.sym);
		this.exprcompile(n.n2);
		if(n.n3 !== null)
			this.statcompile(n.n3);
		this.code.push(void() return thisp.sys.assign(s, thisp.pop()));
		break;
	case ASTDASS:
		if(n.n1.t != ASTSYM)
			error(n.lineno, "invalid lval");
		s = this.sys.getsignal(this.hier, n.n1.sym);
		this.exprcompile(n.n2);
		this.code.push(void(){
			string v;
			v = thisp.pop();
			thisp.sys.nonblock.push(new Event(void() return thisp.sys.assign(s, v), 0));
		});
		break;
	default:
		throw "Process.statcompile: unimplemented " + (string)n.t;
	}
}

void
Process.push(string s)
{
	this.stack.push(s);
}

string
Process.pop()
{
	if(this.stack.length == 0)
		throw "stack underflow";
	return this.stack.pop();
}

void
Process.run()
{
	void f();

	if(this.state == PSLEEP)
		this.state = PACTIVE;
	while(this.state == PACTIVE){
		f = this.code[this.pc++];
		f();
	}
}

void
System.compile(Node n, string hier)
{
	int i;
	string s;
	Process p;

	if(n == null) return;
	switch(n.t){
	case ASTMODULE:
		for(s in n.sym.st.tab)
			switch(n.sym.st.tab[s].t){
			case SYMWIRE:
			case SYMREG:
			case SYMPORT:
				this.addsignal(hier, n.sym.st.tab[s]);
				break;
			}
		for(i = 0; i < n.l.length; i++)
			this.compile(n.l[i], hier);
		break;
	case ASTMINST:
		this.compile(n.sym.def, hier + "." + n.symn.name);
		break;
	case ASTINITIAL:
		p = new Process(this, hier);
		p.statcompile(n.n1);
		p.code.push(function() { p.state = PDEAD; });
		this.schedule(void() return p.run(), 0);
		break;
	case ASTALWAYS:
		p = new Process(this, hier);
		p.statcompile(n.n1);
		p.code.push(function() { p.pc = 0; });
		this.schedule(void() return p.run(), 0);
		break;
	default:
		throw "System.compile: unimplemented " + (string)n.t;
	}
}

void
System.run(void)
{
	int i, j, t;
	Event el[];
	
	for(i = 0; i < 1000; i++){
		if(this.active.length == 0){
			if(this.inactive.length != 0){
				this.active.push.apply(this.active, this.inactive);
				this.inactive.length = 0;
			}else if(this.nonblock.length != 0){
				this.active.push.apply(this.active, this.nonblock);
				this.nonblock.length = 0;
			}else if(this.future.length != 0){
				t = this.future[0].time;
				for(j = 1; j < this.future.length; j++)
					if(this.future[j].time > t)
						break;
				el = this.future.splice(0, j);
				this.active.push.apply(this.active, el);
				this.curtime = t;
			}else
				break;
		}
		this.active.shift().run();
	}
}
