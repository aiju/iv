Node
maxi(Node a, Node b)
{
	return new Node(Node{t: ASTBIN, op: "max", n1: a, n2: b});
}

void
lvalcheck(Node n, bool cont)
{
	void
	lvalcheck0(Node n, bool cont)
	{
		switch(n.t){
		case ASTSYM:
			switch(n.sym.t){
			case SYMPORT:
				if(n.sym.dir == "input")
					error(n.lineno, "assignment to input port '" + n.sym.toString() + "'");
				if(n.sym.portreg && cont)
					error(n.lineno, "continuous assignment to reg '" + n.sym.toString() + "'");
				if(!n.sym.portreg && !cont)
					error(n.lineno, "procedural assignment to wire '" + n.sym.toString() + "'");
				break;
			default:
				error(n.lineno, "invalid lval " + (string)n.sym.t);
			}
			break;
		default:
			error(n.lineno, "lvalcheck: unknown " + (string)n.t);
		}
	}
	
	lvalcheck0(n, cont);
}

void
typecheck(Node n, Type ctxt)
{
	int i;
	TypeType t1, t2;
	bool s;

	switch(n.t){
	case ASTASSIGN:
		typecheck(n.n2, ctxt);
		typecheck(n.n1, ctxt);
		lvalcheck(n.n1, true);
		break;
	case ASTBIN:
		switch(n.op){
		case "==": case "!=": case "<": case "<=":
		case ">": case ">=": case "===": case "!==":
			typecheck(n.n1, null);
			typecheck(n.n2, null);
			break;
		default:
			typecheck(n.n1, ctxt);
			typecheck(n.n2, ctxt);
		}
		n.isconst = n.n1.isconst && n.n2.isconst;
		s = n.n1.type.sign && n.n2.type.sign;
		t1 = n.n1.type.t;
		t2 = n.n2.type.t;
		if(t1 == TYPMEM || t2 == TYPMEM){
			error(n.lineno, "memory in expression");
			n.type = bittype;
			return;
		}
		if(n.op == "or"){
			n.type = eventtype;
			return;
		}
		if(t1 == TYPEVENT || t2 == TYPEVENT){
			error(n.lineno, "event in expression");
			n.type = bittype;
			return;
		}
		if(t1 == TYPREAL || t2 == TYPREAL){
			switch(n.op){
			case "+": case "/": case "%": case "*": case "-": case "**":
				n.type = realtype;
				return;
			case "==": case "!=": case "<": case "<=": case ">": case ">=": case "&&": case "||":
				n.type = bittype;
				return;
			default:
				error(n.lineno, "real as operand to '" + n.op + "'");
				n.type = bittype;
				return;
			}
		}
		switch(n.op){
		case "+": case "/": case "%": case "*": case "-":
		case "&": case "|": case "~^": case "^":
			if(t1 == TYPUNSZ || t2 == TYPUNSZ || ctxt !== null && ctxt.t == TYPUNSZ)
				n.type = s ? sunsztype : unsztype;
			else if(ctxt !== null && (ctxt.t == TYPBITS || ctxt.t == TYPBITV || ctxt.t == TYPBIT))
				n.type = new Type(TYPBITS, s, maxi(maxi(n.n1.type.sz, n.n2.type.sz), ctxt.sz));
			else
				n.type = new Type(TYPBITS, s, maxi(n.n1.type.sz, n.n2.type.sz));
			return;
		case "<<<": case ">>>": case "<<": case ">>": case "**":
			n.type = n.n1.type;
			return;
		case "==": case "!=": case "===": case "!==": case "<": case "<=": case ">": case ">=": case "&&": case "||":
			n.type = bittype;
			return;
		default:
			error(n.lineno, "typecheck: unknown op '" + n.op + "'");
		}
		break;
	case ASTUN:
		typecheck(n.n1, ctxt);
		n.isconst = n.n1.isconst;
		t1 = n.n1.type.t;
		if(t1 == TYPMEM)
			error(n.lineno, "memory in expression");
		else if(t1 == TYPEVENT)
			error(n.lineno, "event in expression");
		if(n.op == "!")
			n.type = bittype;
		else if(n.op == "posedge" || n.op == "negedge")
			n.type = eventtype;
		else if(t1 == TYPREAL){
			if(n.op != "+" && n.op != "-")
				error(n.lineno, "real in expression");
			n.type = n.n1.type;
		}else if(ctxt !== null && ctxt.t == TYPUNSZ || t1 == TYPUNSZ)
			n.type = n.n1.type.sign ? sunsztype : unsztype;
		else if(ctxt !== null && (ctxt.t == TYPBITS || ctxt.t == TYPBITV || ctxt.t == TYPBIT))
			n.type = new Type(TYPBITS, n.n1.type.sign, maxi(n.n1.type.sz, ctxt.sz));
		else
			n.type = n.n1.type;
		break;
	case ASTSYM:
		n.type = n.sym.type;
		break;
	case ASTNUM:
		if(n.num.sz === null)
			n.type = new Type(TYPUNSZ, n.num.sign, null, null, null);
		else
			n.type = new Type(TYPBITS, n.num.sign, new Node(Node{t: ASTCINT, lineno: n.lineno, numi: n.num.sz}), null, null);
		n.isconst = true;
		break;
	case ASTCINT:
		n.type = unsztype;
		n.isconst = true;
		break;
	case ASTMODULE:
		for(i = 0; i < n.stat.length; i++)
			typecheck(n.stat[i], null);
		break;
	default:
		error(n.lineno, "typecheck: unknown " + (string)n.t);
	}
}
